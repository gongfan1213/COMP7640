# **搜索算法与哈希表详解**

## **1. 顺序搜索（Sequential Search）**
### **1.1 基本概念**
- **问题定义**：给定一个记录列表，每个记录有一个关联的键（key），设计高效算法搜索特定键对应的记录。
- **核心思想**：逐个检查数组中的元素，直到找到匹配的键或遍历完所有元素。

### **1.2 伪代码实现**
```python
def sequential_search(array, target):
    for i in range(len(array)):
        if array[i].key == target:
            return array[i]  # 返回找到的记录
    return None  # 未找到
```

### **1.3 时间复杂度分析**
| 情况       | 时间复杂度 | 说明                                                                 |
|------------|------------|----------------------------------------------------------------------|
| **最坏情况** | \( O(n) \) | 目标键在最后一个位置或不存在，需要检查所有 \( n \) 个元素。           |
| **平均情况** | \( O(n) \) | 假设目标键一定存在且概率均匀，平均需要检查 \( \frac{n+1}{2} \) 次。   |

**示例**：  
- 数组大小为 10 时，平均比较次数 = \( \frac{1+2+\cdots+10}{10} = 5.5 \)。

### **1.4 优缺点**
- **优点**：实现简单，适用于无序列表。
- **缺点**：效率低，不适合大规模数据。

---

## **2. 二分搜索（Binary Search）**
### **2.1 基本概念**
- **前提条件**：列表必须**有序**（升序或降序）。
- **核心思想**：通过不断缩小搜索范围（每次排除一半元素）快速定位目标。

### **2.2 伪代码实现**
```python
def binary_search(array, target):
    low, high = 0, len(array) - 1
    while low <= high:
        mid = (low + high) // 2
        if array[mid].key == target:
            return array[mid]  # 找到目标
        elif array[mid].key < target:
            low = mid + 1     # 搜索右半部分
        else:
            high = mid - 1    # 搜索左半部分
    return None  # 未找到
```

### **2.3 时间复杂度分析**
| 情况       | 时间复杂度   | 说明                                                                 |
|------------|--------------|----------------------------------------------------------------------|
| **最坏情况** | \( O(\log n) \) | 每次将搜索范围减半，最多需要 \( \log_2 n \) 次比较。                |
| **平均情况** | \( O(\log n) \) | 与最坏情况相同。                                                   |

**示例**：  
- 对于 \( n=1000 \)，最多只需 10 次比较（因为 \( 2^{10} = 1024 \)）。

### **2.4 与二叉搜索树的关系**
- 二分搜索可以看作是在一个**隐式的平衡二叉搜索树（BST）**中查找：
  - 数组中间元素是根节点。
  - 左子数组对应左子树，右子数组对应右子树。

### **2.5 优缺点**
- **优点**：效率极高，适合静态有序数据。
- **缺点**：要求数据预先排序，插入/删除成本高。

---

## **3. 哈希表（Hash Table）**
### **3.1 基本概念**
- **核心思想**：通过哈希函数将键映射到数组的特定位置（哈希值），实现快速查找。
- **关键组件**：
  1. **哈希函数**：将键转换为数组索引（如 `hash_value = key % table_size`）。
  2. **冲突解决**：处理多个键映射到同一位置的情况。

### **3.2 开放寻址法（Open Addressing）**
#### **插入操作**
1. 计算键的哈希值（如 `506643548 % 701 = 4`）。
2. 若目标位置为空，直接插入；否则**线性探测**（依次检查下一个位置）。
   ```python
   def insert(hash_table, key, record):
       index = hash_function(key)
       while hash_table[index] is not None:
           index = (index + 1) % len(hash_table)  # 线性探测
       hash_table[index] = record
   ```

#### **查找操作**
1. 计算哈希值，检查对应位置。
2. 若键不匹配，继续线性探测，直到找到键或遇到空位。

#### **删除操作**
- 不能直接置空，需标记为“已删除”（如 `DELETED`），避免中断后续查找。

#### **优缺点**
- **优点**：无需额外存储空间。
- **缺点**：易产生聚集现象（Clustering），需动态扩容。

### **3.3 链式哈希（Chained Hashing）**
#### **实现方式**
- 每个哈希桶（bucket）存储一个链表，冲突的键追加到链表末尾。
  ```python
  def insert(hash_table, key, record):
      index = hash_function(key)
      if hash_table[index] is None:
          hash_table[index] = LinkedList()
      hash_table[index].append(record)
  ```

#### **优缺点**
- **优点**：处理冲突简单，适合频繁插入/删除。
- **缺点**：需要额外空间存储指针，最坏情况下退化为链表（\( O(n) \) 查找）。

### **3.4 哈希函数设计原则**
1. **均匀性**：键应均匀分布在哈希表中。
2. **高效性**：计算速度快。
3. **确定性**：同一键始终映射到同一位置。

**常用哈希函数**：
- 取模法：`hash(key) = key % table_size`（需 `table_size` 为质数）。
- 乘法散列法：`hash(key) = floor(table_size * (key * A % 1))`（\( 0 < A < 1 \)）。

### **3.5 时间复杂度**
| 操作       | 平均情况      | 最坏情况      |
|------------|---------------|---------------|
| 插入/查找  | \( O(1) \)    | \( O(n) \)    |
| 删除       | \( O(1) \)    | \( O(n) \)    |

---

## **4. 对比总结**
| 算法         | 适用场景               | 时间复杂度       | 空间复杂度 | 关键要求         |
|--------------|------------------------|------------------|------------|------------------|
| **顺序搜索** | 无序列表               | \( O(n) \)       | \( O(1) \) | 无               |
| **二分搜索** | 静态有序列表           | \( O(\log n) \)  | \( O(1) \) | 必须预先排序     |
| **哈希表**   | 动态数据，快速查找     | \( O(1) \)       | \( O(n) \) | 良好的哈希函数   |

---

## **5. 考试常见问题**
### **5.1 如何选择搜索算法？**
- **数据是否有序**：
  - 有序 → 二分搜索。
  - 无序 → 顺序搜索或哈希表。
- **是否需要频繁插入/删除**：
  - 是 → 哈希表（链式哈希）。
  - 否 → 二分搜索（预处理排序）。

### **5.2 哈希表冲突解决策略对比**
| 策略         | 优点                  | 缺点                  |
|--------------|-----------------------|-----------------------|
| 开放寻址法   | 节省空间              | 易产生聚集现象        |
| 链式哈希     | 处理冲突简单          | 需要额外指针空间      |

### **5.3 实际应用场景**
- **顺序搜索**：小型无序数据集（如联系人列表）。
- **二分搜索**：大型静态数据集（如字典、数据库索引）。
- **哈希表**：高速缓存（如Redis）、编译器符号表。
