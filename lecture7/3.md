根据文档《L7-Basics on Search.pdf》的内容，COMP7640课程第7讲关于序列搜索（Sequential Search）时间复杂度分析的详细知识点如下：

1. 算法定义与伪代码

核心操作：逐一比较数组中的每个元素与目标键值（key）。伪代码：for i from 0 to n-1:
    if a[i] == target:
        return a[i]  # 找到目标
return NULL          # 未找到



2. 时间复杂度分析
(1) 最坏情况（Worst Case）

场景：

目标元素位于数组末尾（a[n-1]）。目标元素不存在于数组中。
操作次数：需完整遍历所有 n 个元素。时间复杂度：O(n)。
(2) 平均情况（Average Case）

假设条件：

所有键值被搜索的概率均等。目标键值一定存在于数组中。
计算过程：

若目标在位置 i，需比较 i+1 次。平均比较次数 = (1 + 2 + ... + n) / n = n(n+1)/2n = (n+1)/2。  
时间复杂度：O(n)（忽略常数因子和低阶项）。

3. 关键结论

效率瓶颈：
序列搜索的时间复杂度与数据规模 n 呈线性关系，适用于小规模或无序数据集，但对大规模数据效率低下。  对比其他算法：

二分搜索（Binary Search）时间复杂度为 O(log n)，但要求数据有序。哈希搜索（Hash Search）平均为 O(1)，但需额外空间开销。


4. 应用场景与局限性

适用场景：

数据未排序或频繁变动。实现简单，适合临时性搜索需求。
局限性：

不适用于高频搜索或大规模数据（如数据库全表扫描需用索引优化）。


附：文档中的具体示例

数组示例：[0]: 281942902  
[1]: 233667136  
[2]: 506643548  
...  
[n-1]: 155778322

搜索键值 506643548：
需遍历到第3个位置（索引2）找到目标，比较次数为3。

文档中未涉及其他搜索算法（如二分搜索、哈希表）的具体分析，仅聚焦于序列搜索的时间复杂度推导。如需其他算法内容，请进一步说明。
