===== 第1页 =====  
COMP7640  
数据库系统与管理  
故障恢复  

===== 第2页 =====  
我们现在的位置？  
用户程序（事务）  
查询优化与执行  
关系运算符  
文件与访问方法  
缓冲区管理  
磁盘空间管理  
数据库  

===== 第3页 =====  
# ACID特性  
**每个事务必须满足以下特性：**  
- **原子性**：所有操作要么全部完成，要么全部不执行。  
- **一致性**：事务完成后不违反任何用户定义的约束。  
- **隔离性**：并发事务互不干扰，每个事务可以认为自己是唯一运行的事务。  
- **持久性**：如果事务提交，其对数据库的更改是永久的，即使系统发生故障。  

===== 第4页 =====  
# 故障分类  
事务可能因多种原因需要中止：  
- 手动取消（人为错误）；  
- 违反用户约束；  
- 软件故障（程序错误）；  
- 硬件问题（存储损坏）；  
- 自然灾害（如地震、洪水等）；  
- 其他原因……  

---  
**系统故障**  

===== 第5页 =====  
# 崩溃示例  
- 系统重启后的期望行为：  
  - T1、T2和T3应该是持久的。  
  - T4和T5应该被中止并重新执行。  

|    | 已提交    | 崩溃！ |  
|---|---|---|  
| T1   |    |    |  
| T2   |    |    |  
| T3   |    |    |  
| T4   |    |    |  
| T5   |    |    |  

===== 第6页 =====  
挑战  
- 数据库系统不知道崩溃前正在执行哪一行。  
- 只知道崩溃后对象的最终值。  
- 示例（初始值：A = 1100美元，B = 2000美元）：  
事务T  
1. read(A)  
2. A = A – 100  
3. write(A)  
4. read(B)  
5. B = B + 100  
6. write(B)  
7. read(B)  
8. B = B – 100  
9. write(B)  
磁盘  
A = 1000  
B = 2000  
崩溃！  

===== 第7页 =====  
高级解决方案  
- 在正常事务处理期间，准备恢复所需的信息。  
- 存储日志记录（例如更多信息）。  
- 在故障/崩溃后，采取措施恢复数据库内容。  
- 使用这些日志记录在系统崩溃后恢复事务。  

===== 第8页 =====  
# 大纲  
- 基于日志的恢复  
  - 延迟修改恢复方法  
  - 立即修改恢复方法  

===== 第9页 =====  
# 延迟修改恢复方法  
- 日志由日志记录组成，存储在磁盘中，创建方式如下：  
  - 在事务T开始前，写入<T start>记录。  
  - 在T执行write(X)前，创建日志记录<T, X, V_new>。  
    - V_new是X的新值。  
  - 在T完成前，创建日志记录<T commit>。  

===== 第10页 =====  
# 日志示例  
- A和B的初始值分别为1000和2000。  

**事务T**  
| read(A) | 日志记录 |  
|---|---|  
| A = A - 50 | <T start> |  
| write(A) | <T, A, 950> |  
| read(B) | <T, B, 2050> |  
| B = B + 50 | <T commit> |  
| write(B) |    |  

===== 第11页 =====  
核心思想  
- 仅创建日志记录，但不立即修改磁盘上数据对象的值。  
- 获取日志后，数据库系统再次扫描日志记录并修改相应数据对象的值。  

===== 第12页 =====  
# 示例  
**事务T**  
read(A)  
A = A - 50  
write(A)  
read(B)  
B = B + 50  
write(B)  

1. 执行  
无修改  
磁盘  
A = 1000  
B = 2000  

2. 创建  
日志记录  
<T start>  
<T, A, 950>  
<T, B, 2050>  
<T commit>  

3. 扫描  
修改  
4. 磁盘  
A = 950  
B = 2050  

===== 第13页 =====  
# 提交前崩溃  
- 系统从崩溃中恢复后，忽略那些没有<T commit>日志记录的事务，并从头重新执行这些事务。（原子性😊）  

| 事务T | 创建 | 日志记录 |  
|---|---|---|  
| read(A) | ⬜️ | <T start> |  
| A = A - 50 | 执行 | <T, A, 950> |  
| write(A) |    |    |  
| read(B) |    | 无<T commit>。这是一个不完整的事务。不扫描日志记录，而是从头重新执行事务T。 |  

===== 第14页 =====  
# 提交后崩溃  
- 系统从崩溃中恢复后，如果已创建完整的日志记录，则需要再次扫描该日志以恢复对象的值。（持久性😊）  

| 事务T | 创建 | 日志记录 |  
|---|---|---|  
| read(A) |    | <T start> |  
| A = A - 50 | 执行 | <T, A, 950> |  
| write(A) |    | <T, B, 2050> |  
| read(B) |    | <T commit> |  
| B = B + 50 |    |    |  
| write(B) |    | 存在<T commit>。这是一个完整的事务。扫描日志记录并修改磁盘上A和B的值。 |  

---  
- 崩溃！  

===== 第15页 =====  
示例（多事务）  
A、B、C的初始值分别为1000、2000和700。先执行T0，再执行T1。  

**事务T0**  
| read(A) | read(C) |  
|---|---|  
| A = A - 50 | C = C - 100 |  
| write(A) | write(C) |  
| read(B) |    |  
| B = B + 50 |    |  
| write(B) |    |  

磁盘  
A = 1000  
B = 2000  
C = 700  

**事务T1**  
| 创建 | 日志记录 |  
|---|---|  
|    | <T0 start> |  
|    | <T0, A, 950> |  
|    | <T0, B, 2050> |  
|    | <T0 commit> |  
|    | <T1 start> |  
|    | <T1, C, 600> |  
|    | <T1 commit> |  

磁盘  
A = 950  
B = 2050  
C = 600  

扫描  

===== 第16页 =====  
# 示例（多事务）  
**事务T1**  
read(A)  
A = A - 50  
write(A)  
read(B)  
B = B + 50  
write(B)  

**事务T2**  
read(C)  
C = C - 100  
write(C)  

**调度S**  
T1: read(A)  
T1: A = A - 50  
T2: read(C)  
T2: C = C - 100  
T1: write(A)  
T2: write(C)  
T2: commit  
T1: read(B)  
T1: B = B + 50  
T1: write(B)  
T1: commit  

===== 第17页 =====  
# 示例（多事务）  
调度S  
T1: read(A)  
T1: A = A - 50  
T2: read(C)  
T2: C = C - 100  
T1: write(A)  
T2: write(C)  
T2: commit  
T1: read(B)  
T1: B = B + 50  
T1: write(B)  
T1: commit  

初始值：A = 1000，B = 600，C = 1000  

**调度S的日志记录**  
- 创建  
  - <T1 start>  
  - <T2 start>  
  - <T1, A, 950>  
  - <T2, C, 900>  
  - <T2 commit>  
  - <T1, B, 650>  
  - <T1 commit>  

===== 第18页 =====  
问题1  
假设系统在使用延迟修改恢复方法执行以下调度时崩溃。描述系统在分别找到以下日志(a)-(b)时如何恢复。  

<T1 start>  
<T1, V, 200>  
<T2 start>  
<T2, L, 300>  
<T1 start>  
<T1, V, 200>  
<T2 start>  
<T2, L, 300>  
<T2, D, 300>  
<T2 commit>  
<T1 start>  
<T1, V, 200>  
<T2 start>  
<T2, L, 300>  
<T2, D, 300>  
<T2 commit>  
<T1, B, 250>  
<T1 commit>  
(a)  
(b)  
(c)  

调度  
<T1 start>  
<T1, V, 200>  
<T2 start>  
<T2, L, 300>  
<T2, D, 300>  
<T2 commit>  
<T1, B, 250>  
<T1 commit>  

===== 第19页 =====  
# 延迟修改恢复方法的缺点  
- 可能较慢，即吞吐量低（事务/秒）。  
  - 仅在数据库系统扫描日志记录时更新对象的值。  
  - 需要扫描所有事务的日志记录。  
- 难以确定何时扫描日志记录。  
  - 如果不及时更新磁盘上对象的值，可能会影响后续事务。  

===== 第20页 =====  
# 立即修改恢复方法  
- 日志由日志记录组成，存储在磁盘中，创建方式如下：  
  - 在事务T开始前，写入<T start>记录。  
  - 在T执行write(X)前，创建日志记录<T, X, V_old>。  
    - V_old是X的旧值。  
  - 在T完成前，创建日志记录<T commit>。  

===== 第21页 =====  
# 日志示例  
- A和B的初始值分别为1000和2000。  

**事务T**  
read(A)  
A = A - 50  
write(A)  
read(B)  
B = B + 50  
write(B)  
commit  

日志记录  
<T start>  
<T, A, 1000>  
<T, B, 2000>  
<T commit>  

（可省略）  

===== 第22页 =====  
核心思想  
- 在执行事务时直接修改磁盘上数据对象（如A、B）的值。  

初始值：A=1000，B=2000  

**事务T**  
read(A)  
A = A - 50  
write(A)  
read(B)  
B = B + 50  
write(B)  

创建  
执行  
磁盘  
修改  
A = 950  
B = 2050  

日志记录  
<T start>  
<T, A, 1000>  
<T, B, 2000>  
<T commit>  

===== 第23页 =====  
# 提交前崩溃  
- **根据日志记录撤销那些在数据库系统恢复时尚未提交的事务的所有修改。（原子性😊）**  

| 事务T | 加载 |  
|---|---|  
| read(A) | 创建 |  
| A = A - 50 | ✔️ |  
| write(A) | 执行 |  
| read(B) | 修改 |  
| B = B + 50 | ✔️ |  
| write(B) | 崩溃！ |  

日志记录  
<T start>  
<T, A, 1000>  

无<T commit>。需要撤销对A的修改。  

磁盘  
A = 950  
B = 2000  

===== 第24页 =====  
# 提交前崩溃  
- **根据日志记录撤销那些在数据库系统恢复时尚未提交的事务的所有修改。（原子性😊）**  

日志记录  
<T start> → 撤销  
<T, A, 1000>  

将A恢复为1000  

磁盘  
A = 95 1000  
B = 2000  

===== 第25页 =====  
# 提交后崩溃  
- 不需要撤销已提交事务的修改。（持久性😊）  

**事务T**  
| read(A) | 创建 | 日志记录 |  
|---|---|---|  
| A = A - 50 | ➡️ | <T start> |  
| write(A) | 执行 | <T, A, 1000> |  
| read(B) |    | <T, B, 2000> |  
| B = B + 50 |    | <T commit> |  
| write(B) |    | 存在<T commit>。 |  

---  
**崩溃！**  

| 修改 | 磁盘 |  
|---|---|  
|    | A = 950 |  
|    | B = 2050 |  

===== 第26页 =====  
问题1的解答  
a) 系统扫描日志记录，发现T1和T2均未提交。它简单地重新执行事务T1和T2。  
b) 系统扫描日志记录，发现T1未提交而T2已提交。因此，在扫描日志记录后，它将L和D修改为300。系统重新执行T1。  
c) 系统扫描日志记录。由于T1和T2均已提交，系统将V、L、D和B分别修改为200、300、300和250。
