好的！我将结合PPT内容，为你详细对比复习**延迟修改（Deferred-Modification）**和**立即修改（Immediate-Modification）**两种恢复方法，包括核心流程、日志规则、恢复策略及典型示例。以下是结构化总结：

---

### **1. 延迟修改恢复方法（Deferred-Modification）**
#### **核心思想**
- **"延迟"**：事务执行期间**不直接修改磁盘数据**，仅记录日志；提交后**批量更新磁盘**。
- **目的**：确保原子性（未提交事务不生效）和持久性（提交事务必生效）。

#### **日志规则**
- **日志记录内容**：
  - `<T start>`：事务T开始。
  - `<T, X, V_new>`：事务T计划将数据项X修改为**新值V_new**（仅记录意图，不实际写磁盘）。
  - `<T commit>`：事务T提交。
- **关键点**：日志中**只存新值**，且所有日志必须**先于磁盘更新**写入磁盘（WAL协议）。

#### **恢复流程**
- **提交前崩溃**：
  - 无`<T commit>`记录 ⇒ 事务T未完成。
  - **操作**：**忽略T的日志**（因磁盘未被修改），需重新执行T。
  - **示例**（PPT Page 13）：
    - 日志：`<T start>`, `<T, A, 950>`（无commit）。
    - 恢复：A保持原值（如1000），T需重头执行。

- **提交后崩溃**：
  - 有`<T commit>`记录 ⇒ 事务T已完成。
  - **操作**：**重做（Redo）**所有`<T, X, V_new>`，将磁盘中的X更新为V_new。
  - **示例**（PPT Page 14）：
    - 日志：`<T start>`, `<T, A, 950>`, `<T, B, 2050>`, `<T commit>`。
    - 恢复：A=950，B=2050（即使崩溃时磁盘未更新）。

#### **优缺点**
- **优点**：简单，避免部分写（Partial Write）问题。
- **缺点**：
  - 低吞吐：提交前数据不可见，后续事务可能被阻塞。
  - 需扫描完整日志（效率低）。

---

### **2. 立即修改恢复方法（Immediate-Modification）**
#### **核心思想**
- **"立即"**：事务执行期间**直接修改磁盘数据**，同时记录日志（保存旧值）。
- **目的**：提高并发性，允许未提交事务的修改对其他事务可见（需隔离机制配合）。

#### **日志规则**
- **日志记录内容**：
  - `<T start>`：事务T开始。
  - `<T, X, V_old>`：事务T修改X前的**旧值V_old**（用于撤销）。
  - `<T commit>`：事务T提交。
- **关键点**：日志中**存旧值**，且日志必须先于磁盘更新（WAL）。

#### **恢复流程**
- **提交前崩溃**：
  - 无`<T commit>`记录 ⇒ 事务T未完成。
  - **操作**：**撤销（Undo）**所有`<T, X, V_old>`，将磁盘中的X恢复为V_old。
  - **示例**（PPT Page 23-24）：
    - 日志：`<T start>`, `<T, A, 1000>`（无commit）。
    - 磁盘：A已被改为950（崩溃前）。
    - 恢复：A回滚到1000。

- **提交后崩溃**：
  - 有`<T commit>`记录 ⇒ 事务T已完成。
  - **操作**：**无需处理**（修改已持久化到磁盘）。
  - **示例**（PPT Page 25）：
    - 日志：`<T start>`, `<T, A, 1000>`, `<T commit>`。
    - 磁盘：A=950（已提交）。
    - 恢复：无需动作。

#### **优缺点**
- **优点**：
  - 高吞吐：数据实时可见，适合高并发。
  - 恢复高效（仅需处理未提交事务）。
- **缺点**：
  - 需处理脏读（依赖隔离级别）。
  - 日志需记录旧值（空间开销略大）。

---

### **3. 对比总结表**
| **特性**               | **延迟修改**                          | **立即修改**                          |
|------------------------|---------------------------------------|---------------------------------------|
| **修改时机**           | 提交后更新磁盘                        | 执行时立即更新磁盘                    |
| **日志内容**           | 新值（V_new）                        | 旧值（V_old）                        |
| **崩溃恢复（未提交）** | 忽略，重新执行事务                    | 撤销（Undo）到旧值                    |
| **崩溃恢复（已提交）** | 重做（Redo）更新磁盘                  | 无需操作（修改已持久化）              |
| **吞吐量**             | 低（延迟更新）                        | 高（实时更新）                        |
| **适用场景**           | 简单系统，对一致性要求高              | 高并发系统，需快速响应                |

---

### **4. 典型试题分析（结合PPT Page 18问题1）**
**题目**：系统崩溃时日志如下，分别用两种方法恢复：  
- **日志(a)**：`<T1 start>`, `<T1, V, 200>`, `<T2 start>`, `<T2, L, 300>`（无commit）。  

**解答**：
1. **延迟修改**：
   - 无`<T1 commit>`和`<T2 commit>` ⇒ 忽略T1、T2，重新执行。
   - 磁盘：V、L保持原值（如V=初始值，L=初始值）。

2. **立即修改**：
   - 无commit ⇒ 撤销T1和T2的修改：
     - 根据`<T1, V, V_old>`恢复V到旧值。
     - 根据`<T2, L, L_old>`恢复L到旧值。

---

### **5. 复习建议**
- **重点记忆**：两种方法的日志格式（新值vs旧值）和恢复动作（Redo vs Undo）。
- **画图辅助**：用PPT中的示例（如Page 12和Page 22）画出事务执行和日志记录的流程图。
- **联系ACID**：思考如何通过这两种方法保证原子性和持久性。

希望这份总结能帮你理清思路！如果需要进一步解释某个示例或概念，可以随时告诉我。
