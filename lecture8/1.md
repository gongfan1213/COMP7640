# **树结构索引详解：ISAM与B+树**

## **1. 索引基础与范围查询**
### **1.1 为什么需要索引？**
- **问题**：在100万条记录中查找年龄20-30的员工
- **无索引**：需要全表扫描，时间复杂度O(n)
- **排序文件+二分查找**：O(logB) I/O（B=数据页数），但仍可能较慢
- **索引解决方案**：构建树结构索引，将I/O次数降至O(logF N)

### **1.2 索引的核心功能**
- **点查询**（精确匹配）
- **范围查询**（如20 ≤ age ≤ 30）
- **高效插入/删除**

---

## **2. ISAM（索引顺序访问方法）**
### **2.1 基本结构**
| 组件          | 内容                          | 示例                     |
|---------------|-------------------------------|--------------------------|
| **索引文件**  | <键值, 记录ID>（排序存储）    | `<23, record1>`          |
| **数据文件**  | 原始记录（无需排序）          | `Ashby, 23, 6003`        |

### **2.2 多级索引**
1. **根节点**：指向最顶层非叶节点
2. **非叶节点**：存储`<键值, 页ID>`，引导搜索方向
3. **叶节点**：存储数据条目`<键值, 记录ID>`

**示例**：
```
根节点 → [31, 38, 44]
          ↓
叶节点 → [23*, 28*, 31*] → [34*, 38*] → [42*, 44*]
```

### **2.3 操作分析**
#### **搜索（22 < age < 32）**
1. 从根节点开始，比较键值确定子树（选择31的左子树）
2. 定位到叶节点`[23*, 28*, 31*]`
3. 返回匹配记录：`Ashby(23)`, `Basu(28)`, `Bristow(31)`

#### **插入（键=25）**
1. 找到对应叶节点`[23*, 28*]`（已满）
2. 创建溢出页存储`25*`，形成链式结构：
   ```
   主页 → [23*, 28*] → 溢出页 → [25*]
   ```

#### **删除（键=25）**
1. 从叶节点或溢出页中删除`25*`
2. 若溢出页为空，则释放空间
3. **问题**：长期删除可能导致"空洞"

### **2.4 成本分析**
- **搜索成本**：`1 + ⌈logF N⌉`次I/O（F=扇出，N=叶页数）
  - 示例：F=100, N=10⁴ → 3次I/O
- **对比二分查找**：`⌈log2 B⌉`次I/O（B=数据页数）
  - 示例：B=10⁵ → 17次I/O

### **2.5 优缺点**
| 优点                      | 缺点                          |
|---------------------------|-------------------------------|
| 适合静态数据              | 溢出页导致性能退化            |
| 范围查询高效              | 删除产生空洞                  |
| 结构简单                  | 无法动态平衡                  |

---

## **3. B+树**
### **3.1 核心特性**
- **动态平衡**：插入/删除自动调整树高
- **高扇出**：每个节点存储大量键值（典型d=100，扇出≈133）
- **结构特性**：
  - **叶节点**：通过双向链表连接，支持高效范围查询
  - **非叶节点**：仅存储导航键值

### **3.2 节点结构**
#### **索引节点**
```
| P0 | K1 | P1 | K2 | P2 | ... | Km | Pm |
```
- **键值范围**：`P0`指向`K < K1`，`Pi`指向`Ki ≤ K < Ki+1`

#### **叶节点**
```
| K1* | K2* | ... | Kn* | Pnext |
```
- 存储实际数据条目（或记录指针）

### **3.3 操作详解**
#### **插入（键=8*）**
1. 找到目标叶节点`[2*, 5*, 7*]`（已满，d=2）
2. **分裂叶节点**：
   - 新节点：`[8*, 14*]`
   - 中间键`5`**复制**到父节点
3. 若父节点溢出，递归分裂（中间键`17`**推送**到新根）

**分裂对比**：
| 节点类型 | 分裂操作          | 键处理方式 |
|----------|-------------------|------------|
| 叶节点   | 均分条目          | 复制中间键 |
| 非叶节点 | 均分条目+保留中间键 | 推送中间键 |

#### **删除（键=24*）**
1. 删除后叶节点`[22*, 27*]`条目不足（d=2）
2. **重分布**：从右兄弟借`29*`，父节点键值更新为`27`
3. **合并**：若无足够兄弟条目，合并节点并调整父节点

### **3.4 实际性能**
- **典型高度**：3-4层
  - 高度4可索引3.1亿条记录（假设扇出133）
- **缓冲池优化**：常驻根节点和部分非叶节点

---

## **4. ISAM vs B+树对比**
| 特性          | ISAM               | B+树                |
|---------------|--------------------|---------------------|
| **结构**      | 静态               | 动态平衡            |
| **插入/删除** | 仅影响叶节点       | 可能调整树高        |
| **溢出处理**  | 使用溢出页         | 节点分裂/合并       |
| **适用场景**  | 只读或低频更新数据 | 高频读写操作        |

---

## **5. 考试常见问题**
### **5.1 计算I/O次数**
- **题目**：100万记录，每页10条数据，叶节点每页100条目，非叶节点每页100条目。
  - **ISAM**：N=10⁴叶页，F=101 → `1 + ⌈log101 10⁴⌉ = 3`次I/O
  - **二分查找**：B=10⁵数据页 → `⌈log2 10⁵⌉ = 17`次I/O

### **5.2 插入/删除操作**
- **关键点**：
  - 叶节点分裂时**复制**中间键
  - 非叶节点分裂时**推送**中间键
  - 删除时优先尝试**重分布**，失败则合并

### **5.3 SQL索引操作**
```sql
-- 创建索引
CREATE INDEX idx_age ON Employees(age);

-- 删除索引
DROP INDEX idx_age;
```

---

## **6. 总结**
- **ISAM**：简单静态索引，适合只读场景，但溢出页和删除空洞是硬伤。
- **B+树**：数据库标准索引，动态平衡、高扇出，支持高效点查和范围查询。
- **核心公式**：
  - ISAM搜索I/O：`1 + ⌈logF N⌉`
  - B+树节点容量：`d ≤ m ≤ 2d`（d=阶数）
