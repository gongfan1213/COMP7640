以下是针对《L09 - Hash Index.pdf》的详细讲解，结合关键概念、示例和实际应用场景，分模块整理成清晰的要点：

---

### **一、哈希索引基础**
#### **1. 核心概念**
- **作用**：高效支持**等值查询**（如 `WHERE age = 22`），但不支持范围查询（如 `WHERE age > 20`）。
- **哈希函数**  
  - 公式：`h(k) = (a × k + b) mod N`  
    - `k`：搜索键（如年龄），`N`：桶数量，`a`/`b`：常数（通常 `a=1, b=2`）。  
  - 要求：均匀分布键值到桶中（避免倾斜）。  
  - **示例**：  
    - `h(age)=age+2`，`N=4` → `h(22)=24 mod 4=0`（分配到桶0）。

#### **2. 静态哈希（Static Hashing）**
- **结构**：  
  - 固定数量的桶（`N`），每个桶对应一个数据页。  
  - 桶满时分配**溢出页**（链表形式），但会导致性能下降。  
- **缺点**：  
  - 数据增长时：溢出链过长，查询效率降低（需遍历链表）。  
  - 数据删除时：空间浪费（空桶无法自动回收）。  
- **解决方案**：定期重建索引（成本高）或改用**动态哈希**。

---

### **二、动态哈希：可扩展哈希（Extendible Hashing）**
#### **1. 核心思想**
- **目录（Directory）**：  
  - 存储指向桶的指针，目录大小随数据动态扩展（如从 `2^d` 扩展到 `2^{d+1}`）。  
  - **全局深度（Global Depth, `d`）**：决定目录的位数（如 `d=2` → 目录有 `00,01,10,11` 四个条目）。  
- **桶（Bucket）**：  
  - **局部深度（Local Depth, `d_A`）**：决定该桶的键值分配位数（`d_A ≤ d`）。  
  - 桶分裂时仅影响局部数据，无需全局重组。

#### **2. 工作流程**
- **插入（Insert）**：  
  1. 计算 `h(k)` 的最后 `d` 位，找到对应桶。  
  2. 若桶未满，直接插入；否则：  
     - **分裂桶**：按 `d_A + 1` 位重新分配键值（如原桶 `d_A=2`，新桶用3位）。  
     - **扩展目录**：若 `d_A == d`，则目录大小翻倍（`d++`）。  
- **示例**（插入 `20*`）：  
  - `20=10100`，最后2位=`00` → 桶A（已满）。  
  - 分裂桶A为 `A`（`000`/`100`）和 `A2`（`010`/`110`），目录扩展为3位。

- **删除（Delete）**：  
  1. 删除键值后，若桶为空且可合并（与“分裂镜像”桶共享 `d_A-1` 位），则合并。  
  2. 若所有桶的 `d_A ≤ d-1`，目录减半（`d--`）。

#### **3. 优势 vs 静态哈希**
| **特性**               | **静态哈希**               | **可扩展哈希**               |
|------------------------|--------------------------|----------------------------|
| 桶数量                 | 固定                     | 动态增长                   |
| 溢出处理               | 溢出页（性能低）          | 无溢出页（目录扩展）        |
| 适用场景               | 数据量稳定               | 数据频繁增删               |

---

### **三、关键示例解析**
#### **1. 静态哈希示例（Question 1）**
- **参数**：`h(k)=k+2`，`N=4`，每页7字节（每键4字节，每页存1键+指针）。  
- **操作序列**：插入3,7,2,12,17,4,10 → 删除2。  
  - **步骤**：  
    - 插入3：`h(3)=5 mod 4=1` → 桶1。  
    - 插入7：`h(7)=9 mod 4=1` → 桶1（需溢出页）。  
    - 删除2：`h(2)=4 mod 4=0` → 清空桶0的键2。

#### **2. 可扩展哈希示例（Question 3）**
- **初始状态**：  
  - 目录：`00,01,10,11`（`d=2`）。  
  - 桶A：`4*,12*,32*,16*`（`d_A=2`）。  
- **插入 `9*`（1001）**：  
  - 最后2位=`01` → 桶B（`1*,5*,21*,13*` 已满）。  
  - 分裂桶B：按 `d_B+1=3` 位分配（`001` vs `101`），目录扩展为3位。

---

### **四、面试常见问题**
1. **为什么用最后 `d` 位计算桶ID？**  
   - 等价于 `h(k) mod 2^d`（二进制取模高效）。  
   - 示例：`h(k)=k`，`d=3` → `20 mod 8=4`（`100`），取最后3位=`100`。

2. **目录扩展的触发条件？**  
   - 当分裂桶的 `d_A == d` 时，需扩展目录（如 `d=2` → `d=3`，目录从4到8项）。

3. **如何处理哈希冲突？**  
   - 可扩展哈希中，不同键可能哈希到同一桶（需分裂桶）；静态哈希中，使用溢出页。

---

### **五、总结**
- **哈希索引**：适合等值查询，避免全表扫描。  
- **静态哈希**：简单但扩展性差，适合静态数据集。  
- **可扩展哈希**：动态调整，无溢出页，适合动态数据。  

**实际应用**：数据库索引（如MySQL的HASH索引）、缓存系统（如Redis哈希表）。
